import type { JiraClient } from "../jira/jira-client.ts";
import type { JiraIssue } from "../jira/jira-models.ts";
import { gitlabClient } from "../shared.ts";
import { addAll, checkoutBranch, commit, push } from "../utils/git.ts";
import logger from "../utils/logger.ts";
import { createClient, promptAndWaitForResponse } from "./opencode-helper.ts";

/**
 * Fix a bug from a Jira issue and create a merge request in GitLab
 * @param jiraClient - The Jira API client
 * @param jiraIssue - The Jira issue containing the bug to fix
 * @param clonePath - Path to the cloned repository
 * @param projectId - GitLab project ID
 * @param projectPath - GitLab project path (e.g., "namespace/project")
 * @returns Summary of the bug fix and created MR
 */
export async function createMRForBugFix(
	jiraClient: JiraClient,
	jiraIssue: JiraIssue,
	clonePath: string,
	projectId: string | number,
	_projectPath: string,
): Promise<string> {
	logger.info(
		{
			issueKey: jiraIssue.key,
			projectId,
			clonePath,
		},
		"Creating MR for bug fix",
	);

	// Create OpenCode client for AI assistance
	const { client: opencodeClient } = await createClient(clonePath);

	try {
		// Step 1: Analyze the bug from the Jira issue
		logger.debug({ issueKey: jiraIssue.key }, "Analyzing bug description");

		const bugDescription = `
Issue: ${jiraIssue.fields.summary}
Description: ${jiraIssue.fields.description || "No description provided"}
Status: ${jiraIssue.fields.status.name}
Priority: ${jiraIssue.fields.priority?.name || "Not set"}
`;

		const analysisPrompt = `You are analyzing a bug reported in Jira issue ${jiraIssue.key}.

${bugDescription}

Please analyze this bug and create a fix. Follow these steps:
1. Understand the bug from the description
2. Locate the relevant code files
3. Implement the fix
4. Test that your fix works

After implementing the fix, provide a summary of:
- What was the root cause
- What files you changed
- What the fix does

Work in the current directory: ${clonePath}`;

		logger.info({ issueKey: jiraIssue.key }, "Requesting AI to fix the bug");
		const fixSummary = await promptAndWaitForResponse(
			opencodeClient,
			analysisPrompt,
		);

		logger.debug({ issueKey: jiraIssue.key }, "Bug fix completed by AI");

		// Step 2: Create a new branch for the fix
		const branchName = `fix/${jiraIssue.key.toLowerCase()}-${Date.now()}`;
		logger.info({ branchName, projectId }, "Creating new branch for fix");

		// Get the default branch from project
		const project = await gitlabClient.getProject(projectId);
		const baseBranch = project.default_branch || "main";

		const branch = await gitlabClient.createBranch(projectId, {
			branch: branchName,
			ref: baseBranch,
		});

		logger.info(
			{ branchName: branch.name, projectId },
			"Branch created successfully",
		);

		// Step 3: Checkout the new branch and commit AI changes
		logger.info(
			{ branchName, clonePath },
			"Checking out new branch and committing AI changes",
		);

		// Checkout the new branch in the cloned repo
		await checkoutBranch(clonePath, branchName, false);
		logger.debug({ branchName, clonePath }, "Checked out new branch");

		// Stage all changes made by the AI
		await addAll(clonePath);
		logger.debug({ clonePath }, "Staged all changes");

		// Create commit with descriptive message
		const commitMessage = `fix: ${jiraIssue.fields.summary}

Fixes ${jiraIssue.key}

This fix was automatically generated by Bibus bot based on the bug report.`;

		await commit(clonePath, commitMessage);
		logger.info({ commitMessage, branchName }, "Created commit");

		// Push to remote
		await push(clonePath, "origin", branchName);
		logger.info({ branchName }, "Pushed changes to remote");

		// Step 4: Create merge request
		const mrTitle = `Fix: ${jiraIssue.fields.summary} [${jiraIssue.key}]`;
		const mrDescription = `
## Bug Fix for ${jiraIssue.key}

### Original Issue
${bugDescription}

### Fix Summary
${fixSummary}

---
*This MR was automatically generated by Bibus bot*
*Jira Issue: ${jiraIssue.key}*
`;

		logger.info(
			{ branchName, baseBranch, title: mrTitle },
			"Creating merge request",
		);

		const mergeRequest = await gitlabClient.createMergeRequest(projectId, {
			source_branch: branchName,
			target_branch: baseBranch,
			title: mrTitle,
			description: mrDescription,
			labels: ["bot-generated", "bug-fix", jiraIssue.key],
			remove_source_branch: true,
		});

		logger.info(
			{ mrIid: mergeRequest.iid, mrUrl: mergeRequest.web_url },
			"Merge request created successfully",
		);

		// Step 5: Link MR back to Jira issue
		try {
			logger.info(
				{ issueKey: jiraIssue.key, mrUrl: mergeRequest.web_url },
				"Creating remote link in Jira",
			);

			await jiraClient.createRemoteLink(jiraIssue.key, {
				url: mergeRequest.web_url,
				title: `Merge Request !${mergeRequest.iid}`,
				summary: `Fix for ${jiraIssue.key}: ${jiraIssue.fields.summary}`,
				icon: {
					url16x16: "https://gitlab.com/favicon.ico",
					title: "GitLab",
				},
				relationship: "fixes",
			});

			logger.info(
				{ issueKey: jiraIssue.key, mrUrl: mergeRequest.web_url },
				"Remote link created successfully",
			);
		} catch (error) {
			// Don't fail the whole operation if remote link creation fails
			logger.warn(
				{ error, issueKey: jiraIssue.key, mrUrl: mergeRequest.web_url },
				"Failed to create remote link in Jira, but MR was created successfully",
			);
		}

		return `âœ… Merge request created successfully!

**MR**: ${mergeRequest.web_url}
**Branch**: ${branchName}
**Title**: ${mrTitle}

${fixSummary}`;
	} catch (error) {
		logger.error(
			{ error, issueKey: jiraIssue.key },
			"Failed to create MR for bug fix",
		);
		throw error;
	}
}
